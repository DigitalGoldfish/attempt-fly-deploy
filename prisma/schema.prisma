// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id       String @id @default(cuid())
  email    String @unique
  username String @unique
  name     String
  kuerzel  String @default("")
  status   String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  defaultTags Tag[]
  image       UserImage?
  password    Password?
  notes       Note[]
  roles       Role[]
  sessions    Session[]
  connections Connection[]
  bereich     Bereich[]
}

model Bereich {
  id    String @id @default(cuid())
  name  String
  label String

  tags  Tag[]
  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id    String @id @default(cuid())
  label String
  type  String

  bereich   Bereich? @relation(fields: [bereichId], references: [id])
  bereichId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User[]
}

model Note {
  id      String @id @default(cuid())
  title   String
  content String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String

  images NoteImage[]

  // non-unique foreign key
  @@index([ownerId])
  // This helps our order by in the user search a LOT
  @@index([ownerId, updatedAt])
}

model NoteImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  noteId String

  // non-unique foreign key
  @@index([noteId])
}

model UserImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Password {
  hash String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Session {
  id             String   @id @default(cuid())
  expirationDate DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  // non-unique foreign key
  @@index([userId])
}

model Permission {
  id          String @id @default(cuid())
  action      String // e.g. create, read, update, delete
  entity      String // e.g. note, user, etc.
  access      String // e.g. own or any
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles Role[]

  @@unique([action, entity, access])
}

model Role {
  id          String @id @default(cuid())
  name        String @unique
  label       String @default("")
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  permissions Permission[]
}

model Verification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The type of verification, e.g. "email" or "phone"
  type String

  /// The thing we're trying to verify, e.g. a user's email or phone number
  target String

  /// The secret key used to generate the otp
  secret String

  /// The algorithm used to generate the otp
  algorithm String

  /// The number of digits in the otp
  digits Int

  /// The number of seconds the otp is valid for
  period Int

  /// The valid characters for the otp
  charSet String

  /// When it's safe to delete this verification
  expiresAt DateTime?

  @@unique([target, type])
}

model Connection {
  id           String @id @default(cuid())
  providerName String
  providerId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  @@unique([providerName, providerId])
}

model MailAttachment {
  id            String  @id @default(cuid())
  contentType   String
  fileName      String
  size          Int
  blob          Bytes
  previewImages String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  mail   Mail   @relation(fields: [mailId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  mailId String

  // non-unique foreign key
  @@index([mailId])
}

model Mail {
  id        String @id @default(cuid())
  sender    String
  recipient String

  subject     String
  message     String
  attachments MailAttachment[]

  type       String
  receivedAt DateTime @default(now())

  forwardedTo String?
  forwardedAt DateTime?
  Incoming    Incoming[]
}

model FormSubmission {
  id       String    @id @default(cuid())
  document Document?

  message    String?
  incoming   Incoming[]
  receivedAt DateTime   @default(now())
}

model Document {
  id          String @id @default(cuid())
  type        String // Unknown, Vorschreibung, KV, KV-Best√§tigung
  contentType String
  blob        Bytes

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  referencedIn Incoming[] @relation("additionalDocuments")
  incoming     Incoming?  @relation("default")

  formSubmission   FormSubmission @relation(fields: [formSubmissionId], references: [id])
  formSubmissionId String         @unique
}

model Incoming {
  id             String          @id @default(cuid())
  source         String
  mail           Mail?           @relation(fields: [mailId], references: [id])
  formSubmission FormSubmission? @relation(fields: [formSubmissionId], references: [id])
  document       Document?       @relation("default", fields: [documentId], references: [id])
  documentId     String?         @unique

  // faxdienst
  type        String  @default("Unknown")
  bereich     String?
  mitarbeiter String?
  kundennr    String?
  neuanlage   Boolean @default(false)
  kvnotwendig Boolean @default(false)

  // kundendienst
  documents Document[] @relation("additionalDocuments")
  orderNr   String?

  status  String
  comment String?

  printed   Boolean   @default(false)
  printedAt DateTime?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  mailId           String?
  formSubmissionId String?
}
