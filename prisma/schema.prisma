// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id       String @id @default(cuid())
  email    String @unique
  username String @unique
  name     String
  kuerzel  String @default("")
  status   String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  defaultTags Tag[]
  image       UserImage?
  password    Password?
  notes       Note[]
  roles       Role[]
  sessions    Session[]
  connections Connection[]
  bereich     Bereich[]
  Issues      Issues[]
}

model Bereich {
  id    String @id @default(cuid())
  name  String
  label String

  tags  Tag[]
  users User[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Tag {
  id    String @id @default(cuid())
  label String
  type  String

  bereich   Bereich? @relation(fields: [bereichId], references: [id])
  bereichId String?

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  User      User[]
  Incoming  Incoming[]
}

model Note {
  id      String @id @default(cuid())
  title   String
  content String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerId String

  images NoteImage[]

  // non-unique foreign key
  @@index([ownerId])
  // This helps our order by in the user search a LOT
  @@index([ownerId, updatedAt])
}

model NoteImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  noteId String

  // non-unique foreign key
  @@index([noteId])
}

model UserImage {
  id          String  @id @default(cuid())
  altText     String?
  contentType String
  blob        Bytes

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Password {
  hash String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @unique
}

model Session {
  id             String   @id @default(cuid())
  expirationDate DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  // non-unique foreign key
  @@index([userId])
}

model Permission {
  id          String @id @default(cuid())
  action      String // e.g. create, read, update, delete
  entity      String // e.g. note, user, etc.
  access      String // e.g. own or any
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  roles Role[]

  @@unique([action, entity, access])
}

model Role {
  id          String @id @default(cuid())
  name        String @unique
  label       String @default("")
  description String @default("")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users       User[]
  permissions Permission[]
}

model Verification {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// The type of verification, e.g. "email" or "phone"
  type String

  /// The thing we're trying to verify, e.g. a user's email or phone number
  target String

  /// The secret key used to generate the otp
  secret String

  /// The algorithm used to generate the otp
  algorithm String

  /// The number of digits in the otp
  digits Int

  /// The number of seconds the otp is valid for
  period Int

  /// The valid characters for the otp
  charSet String

  /// When it's safe to delete this verification
  expiresAt DateTime?

  @@unique([target, type])
}

model Connection {
  id           String @id @default(cuid())
  providerName String
  providerId   String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  @@unique([providerName, providerId])
}

model Mail {
  id        String @id @default(cuid())
  sender    String
  recipient String

  subject     String
  message     String
  attachments Document[]

  type       String
  receivedAt DateTime @default(now())

  forwardedTo String?
  forwardedAt DateTime?
  Incoming    Incoming[]
}

model FormSubmission {
  id       String    @id @default(cuid())
  document Document?

  message    String?
  incoming   Incoming[]
  receivedAt DateTime   @default(now())
}

model Incoming {
  id             String          @id @default(cuid())
  source         String
  mail           Mail?           @relation(fields: [mailId], references: [id])
  formSubmission FormSubmission? @relation(fields: [formSubmissionId], references: [id])

  // faxdienst
  type        String  @default("Unknown")
  bereich     String?
  mitarbeiter String?
  kundennr    String?
  bestellnr   String?
  neuanlage   Boolean @default(false)

  deletionReason String?

  tags Tag[]

  // attribute
  ohneverordnung Boolean   @default(false)
  kvuploaded     Boolean   @default(false)
  kvsent         Boolean   @default(false)
  kvreceived     Boolean   @default(false)
  inquiry        Boolean   @default(false)
  produktanlage  Boolean   @default(false)
  wiedervorlage  DateTime?

  kvbestaetigung   Incoming? @relation("kvbestaetigung", fields: [kvbestaetiungsId], references: [id])
  kvbestaetiungsId String?   @unique
  verordnung       Incoming? @relation("verordnung", fields: [kvbestaetiungsId], references: [id])
  verordnungsId    String?   @unique

  // kundendienst
  documents Document[]
  orderNr   String?

  svtraeger   SVTraeger? @relation(fields: [svTraegerId], references: [id])
  svTraegerId String?

  status  String
  comment String?

  printed   Boolean   @default(false)
  printedAt DateTime?

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt
  mailId              String?
  formSubmissionId    String?
  verordnung_fuer     Incoming? @relation("verordnung")
  kvbestaetigung_fuer Incoming? @relation("kvbestaetigung")
}

model Document {
  id            String  @id @default(cuid())
  contentType   String
  fileName      String
  size          Int
  height        Int?
  width         Int?
  blob          Bytes
  previewImages String?
  rotation      Int @default(0)


  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  incoming   Incoming? @relation(fields: [incomingId], references: [id])
  incomingId String?

  formSubmission   FormSubmission? @relation(fields: [formSubmissionId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  formSubmissionId String?         @unique

  mail   Mail?   @relation(fields: [mailId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  mailId String?
}

model Issues {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id])
  userId String
  note   String
  link   String
}

model SVTraeger {
  id       String     @id @default(cuid())
  name     String
  email    String
  fax      String
  Incoming Incoming[]
}
